package Human_10;

import java.io.Serializable;

/**
 * Created by Dagon on 18.12.2014.
 * public String toString()
 Возвращает строковое представление объекта. Вообще, toString метод возвращает строку, которая "дословно представляет" этот объект.
 Результатом должно быть краткое, но информативное представление, которое легко для человека читать. Рекомендуется, чтобы все подклассы переопределили этот метод.
 toString метод для класса Object возвращает строку, состоящую из имени класса, которого объект является экземпляром, символ знака at-sign`@',
 и шестнадцатеричное представление без знака хэш-кода объекта. Другими словами этот метод возвращает строку, равную значению:

 getClass().getName() + '@' + Integer.toHexString(hashCode())

 Возвраты:
 строковое представление объекта.

 public int hashCode()
 Возвращает значение хэш-кода для объекта. Этот метод поддерживается в пользу хэш-таблиц, таких как обеспеченные HashMap.
 Общий контракт hashCode :

 Всякий раз, когда это вызывается на тот же самый объект не раз во время выполнения приложения Java, hashCode метод должен последовательно возвращать то же самое
 целое число, не предоставил информации, используемой в equals сравнения на объекте изменяются. Эта целочисленная потребность не остается непротиворечивой от одного выполнения приложения к другому выполнению того же самого приложения.
 Если два объекта равны согласно equals(Object) метод, затем вызывая hashCode метод на каждом из двух объектов должен привести к тому же самому целочисленному результату.
 Не требуется это, если два объекта неравны согласно equals(java.lang.Object) метод, затем вызывая hashCode метод на каждом из двух объектов должен привести к
 отличным целочисленным результатам. Однако, программист должен знать, что приведение к отличным целочисленным результатам для неравных объектов может улучшить производительность хэш-таблиц.
 Столько, сколько разумно практично, метод хэш-кода, определенный классом Object действительно возвращает отличные целые числа для отличных объектов.
 (Это обычно реализуется, преобразовывая внутренний адрес объекта в целое число, но этот метод реализации не требуется языком программирования JavaTM.)

 Возвраты:
 значение хэш-кода для этого объекта.

 public boolean equals(Object obj)
 Указывает, " ли некоторый другой объект равен" этому.
 equals метод реализует отношение эквивалентности на ненулевых ссылках на объект:

 Это рефлексивно: для любого ненулевого ссылочного значения x, x.equals(x) должен возвратиться true.
 Это симметрично: для любых ненулевых ссылочных значений x и y, x.equals(y) должен возвратиться true если и только если y.equals(x) возвраты true.
 Это является переходным: для любых ненулевых ссылочных значений x, y, и z, если x.equals(y) возвраты true и y.equals(z) возвраты true, тогда x.equals(z)
 должен возвратиться true.
 Это является непротиворечивым: для любых ненулевых ссылочных значений x и y, многократные вызовы x.equals(y) последовательно возвращайтесь true
 или последовательно возвращайтесь false, предоставленный никакая информация, используемая в equals сравнения на объектах изменяются.
 Для любого ненулевого ссылочного значения x, x.equals(null) должен возвратиться false.
 equals метод для класса Object реализует самое отличительное отношение эквивалентности на объектах; то есть, для любых ненулевых ссылочных значений x и y,
 этот метод возвраты true если и только если x и y обратитесь к тому же самому объекту (x == y имеет значение true).

 Отметьте, что обычно необходимо переопределить hashCode метод всякий раз, когда этот метод переопределяется, чтобы поддержать общий контракт для hashCode метод,
 который утверждает, что у равных объектов должны быть равные хэш-коды.

 Параметры:
 obj - ссылочный объект, с которым можно сравниться.
 Возвраты:
 true если этот объект является тем же самым как obj параметром; false иначе.

 protected Object clone()
 throws CloneNotSupportedException
 Создает и возвращает копию этого объекта. Точное значение "копии" может зависеть от класса объекта. Общее намерение состоит в том что для любого объекта x, выражение:
 x.clone() != x
 будет истина, и что выражение:
 x.clone().getClass() == x.getClass()
 будет true, но они не абсолютные требования. В то время как это обычно имеет место что:
 x.clone().equals(x)
 будет true, это не абсолютное требование.
 Условно, возвращенный объект должен быть получен, вызывая super.clone. Если класс и все его суперклассы (кроме Object) повинуйтесь этому соглашению,
 оно будет иметь место это x.clone().getClass() == x.getClass().
 Условно, объект, возвращенный этим методом, должен быть независимым от этого объекта (который клонируется). Чтобы достигнуть этой независимости,
 может быть необходимо изменить одно или более полей объекта, возвращенного super.clone прежде, чем возвратить это. Как правило, это означает копировать
 любые изменчивые объекты, которые включают внутреннюю "глубинную структуру" клонируемого объекта и заменяющий ссылки на эти объекты со ссылками на копии.
 Если класс содержит только примитивные поля или ссылки на неизменные объекты, то он обычно имеет место что никакие поля в объекте, возвращенном super.clone потребность, которая будет изменена.
 Метод clone для класса Object выполняет определенную работу клонирования. Во-первых, если класс этого объекта не реализует интерфейс Cloneable, тогда a CloneNotSupportedException бросается. Отметьте, что все массивы, как полагают, реализуют интерфейс Cloneable и что тип возврата clone метод типа массива T[] T[] где T является любым ссылочным типом или типом примитива. Иначе, этот метод создает новый экземпляр класса этого объекта и инициализирует все его поля с точно содержанием соответствующих полей этого объекта, как будто присвоением; содержание полей самостоятельно не клонируется. Таким образом этот метод выполняет "мелкую копию" этого объекта, не "глубокой копии" работа.
 Класс Object самостоятельно не реализует интерфейс Cloneable, так вызов clone метод на объекте, класс которого Object приведет к выдаче исключения во время выполнения.

 Возвраты:
 клон этого экземпляра.
 */
public class Human implements Serializable,Cloneable{

    enum Sex {MAN, WOMAN}
    enum Temperament {CHOLERIC, PHLEGMATIC, MELANCHOLIC, SANGUINE }

    String Name;
    int age;
    Sex sex;
    Temperament temperament;

    @Override
    public String toString() {
        return "Human "+Name+" " + age+ " " +sex;
    }

    @Override
    public int hashCode() {
        int result = Name.hashCode();
        result = 31 * result + age;
        return result;
    }

    public Human(String Name, int age, Sex sex, Temperament temperament) {
        this.Name = Name;
        this.age = age;
        this.sex = sex;
        this.temperament = temperament;
    }
    @Override
    public boolean equals (Object obj) {
        if (obj== null)
            return false;
        if (this.getClass() != obj.getClass())
            return false;
        Human other = (Human)obj;
        return (this.Name == other.Name) &&
                (this.age == other.age) &&
                (this.sex == other.sex) &&
                (this.temperament == other.temperament);
  }
    @Override
    public Object clone() throws CloneNotSupportedException {
        Human h = (Human) super.clone();
        return h;

    }
}
